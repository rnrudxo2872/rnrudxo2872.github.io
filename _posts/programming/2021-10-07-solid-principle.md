---
date: 2021-10-07
title: "solid 5 원칙이란?"
categories:
  - 개인공부
  - 프로그래밍
tags:
  - 프로그래밍
  - 객체지향
---

1. 단일 책임 원칙(Single Responsibility Principle)
   <code>같은 이유로 변경될 코드들은 모으고, 다른 이유로 변경될 코드들은 흩어라</code><br>
   해당 원직은 객체 지향에 중요한 부분이다. GUI 코드와 비즈니스 로직을 섞어 놓는 경우는 없다. SQL 쿼리와 통신 프로토콜을 섞어놓는 경우도 없기 때문.  
   한 부분을 수정했을 때 다른 부분에 버그가 생기지 않도록, 다른 이유로 변경될 코드들은 흩어놓는다. 우리는 다른 이유로 변경될 모듈들끼리 의존성을 가지지 않도록 해야 한다는 원칙이다.  
   만약 다른 이유로 변경될 코드들을 한 곳에 작성한다면, 스파게티 서비스 집합을 만들 수 도 있다.

- 해당 SRP원칙을 따른다면, 응집도는 높고 결합도는 낮게 설계할 수 있다.
  - 응집도: 한 프로그램의 요소가 얼마나 뭉쳐있는지, 즉 구성 요소들 사이의 응집력을 말한다.
  - 결합도: 프로그램 구성 요소들 사이가 얼마나 의존적인지 말한다.

1. 개방-폐쇄의 원칙 (Open-Closed Principle)
   <code>모듈의 확장에 열려있으며, 변경에는 닫혀 있어야 한다.</code><br>
   즉, <code>기존의 코드</code>를 변경하지 않고(closed), 기능을 추가할 수 있도록(open) 설계가 되어야 한다는 원칙을 말한다. 예로 들면, 모든 자식들에 어떤 기능이 추가 되어야 한다면, 해당 부모 클래스(or 인터페이스)에 기능을 설계하면 공통으로 사용할 수 있기에, 원칙에 따르는 것이다.

1. 리스코프 치환 원칙 (Liskov Substitution Principle)
   <code>어떠한 인터페이스를 사용하는 프로그램은 해당 인터페이스의 구현체(implementaion)에 의해 동작이 오락가락 하면 안된다.</code><br>
   해당 말을 풀어서 한다면, 부모 클래스의 행위를 자식 클래스가 대체할 수 있어야 한다는 뜻이다. 하지만 여기서 만약 같은 함수를 다시 재정의 하는 오버라이딩을 한다면? 그것은 해당 원칙에 위배되는 행위이다. 만약 추가된 기능을 사용하면? 위배다.  
   즉 LSP는 서브 클래스가 슈퍼 클래스의 책임을 무시하거나 재정의 하지 않고, 확장만 수행한다는 것을 의미한다. 부모가 수행하는 책임은 그대로 수행하나, 추가적인 필드나 기능을 제공하려는 경우에만 상속하는게 바람직하다는 원칙이다.

1. 인터페이스 분리 원칙(Interface Segregation Principle)
   <code>사용자가 필요하지 않은 것들에 의존하게 되지 않도록, 인터페이스를 작게 유지하라</code><br>
   해당 원칙은, 클라이언트가 자신이 사용하지 않는 기능에는 영향을 받지 않아야 한다는 내용이다.  
   예를 들어 관리자용 인터페이스와 클라이언트 인터페이스가 따로 있지 않고, 통합 인터페이스를 사용한다면 해당 원칙에 위배되는 행위이다. 즉, 다양한 기능을 인터페이스화 함으로써 관련 없는 인터페이스의 영향을 받지 않아야 한다는 것이다.

1. 의존 역전 원칙(Dependency Inversion Priciple)
   <code>추상화하는 방향으로 의존하되, 상위 레벨 모듈이 하위 레벨 세부 사항에 의존해서는 안된다.</code><br>
   의존관계를 맺을 때 변화하기 쉬운 것 또는 자주 변화하는 것보다 **변화하기 어려운 것**에 의존하라는 원칙이다.  
   추상화한 클래스 또는 인터페이스를 참조하고, 해당 요소들을 관리함으로써 변경사항에 유연하게 대처할 수 있고, 변화하는 부분을 추상화하며, 변화가 되지 않는 형태로 만든 것을 의존하기에 OCP(개방-폐쇄) 또한 만족한다.
